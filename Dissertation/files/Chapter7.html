<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.33">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>chapter7</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Chapter7_files/libs/clipboard/clipboard.min.js"></script>
<script src="Chapter7_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Chapter7_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Chapter7_files/libs/quarto-html/popper.min.js"></script>
<script src="Chapter7_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Chapter7_files/libs/quarto-html/anchor.min.js"></script>
<link href="Chapter7_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Chapter7_files/libs/quarto-html/quarto-syntax-highlighting-ea385d0e468b0dd5ea5bf0780b1290d9.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Chapter7_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Chapter7_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Chapter7_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">




<p>This chapter aims to examine the utility of the integrated likelihood function as a tool for estimating the weighted sum of a group of independent and distinct Poisson rates. We will compare and contrast the performances of the point and interval estimators it produces under three different model frameworks, using the analogous estimators produced by the profile likelihood function as a benchmark within each framework. The models we will consider are (i) a naive model in which we estimate the Poisson rate in each group using only the group’s observed count and exposure time, (ii) a generalized linear regression model with fixed effects in which we assume there is an underlying covariate structure influencing the observed counts in each group, and (iii) a hierarchical mixed effects regression model in which we assume some or all of the intercepts and slopes from the previous model are random effects instead of fixed. We will also consider the robustness of the pseudolikelihood-derived estimators to model misspecification when evaluating their performance.</p>
<p>Consider a group of <span class="math inline">\(G\)</span> independent Poisson processes having distinct rates per unit time of <span class="math inline">\(\theta_1, ..., \theta_G\)</span>. Let <span class="math inline">\(Y_g\)</span> denote the running tally of observations that we record from the <span class="math inline">\(g\)</span>-th process during an interval of time <span class="math inline">\(t_g\)</span>, so that <span class="math display">\[Y_g \sim \text{Poisson}(t_g\theta_g).\]</span> Suppose we are interested in estimating a weighted sum of these Poisson rates, i.e.&nbsp;our parameter of interest is <span class="math display">\[\psi = \sum_{g=1}^G \alpha_g \theta_g,\]</span> where <span class="math inline">\(\alpha_1, ..., \alpha_G\)</span> are known positive weights. Letting <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\theta\)</span> denote the column vectors of their constituent elements, we can also write this using the more compact notation <span class="math display">\[\psi = \alpha^\top \theta.\]</span></p>
<p>Let <span class="math inline">\(Y = (Y_1, ..., Y_G)^\top\)</span> represent the vector of recorded counts from each group. The log-likelihood for <span class="math inline">\(\theta\)</span> is <span class="math display">\[\ell(\theta; Y) = \sum_{g=1}^G \big(Y_g \log \theta_g - t_g \theta_g\big),\]</span> where we have discarded any additive terms not depending on <span class="math inline">\(\theta\)</span>. The unconstrained MLE for <span class="math inline">\(\theta\)</span> is <span class="math inline">\(\hat{\theta} = \Big(\frac{Y_1}{t_1}, ..., \frac{Y_G}{t_G}\Big)^{\top}\)</span>, and the corresponding unconstrained MLE for <span class="math inline">\(\psi\)</span> is <span class="math inline">\(\hat{\psi} = \alpha^\top \hat{\theta}\)</span>.</p>
<p>Because <span class="math inline">\(\psi\)</span> is a function of the full model parameter, there is no explicit nuisance parameter over which can integrate to obtain an integrated likelihood for it. Instead, we must use the ZSE parameterization method for an implicit nuisance parameter introduced in <span class="citation" data-cites="severini2018">@severini2018</span> to approximate the integral. See also chapters 4 and 5 for a more general discussion of the ZSE parameter and the role it plays in constructing integrated likelihood functions with desirable properties.</p>
<p>Consider the subspace <span class="math inline">\(\Omega_{\hat{\psi}} = \{\omega \in \Theta: \alpha^\top \omega = \hat{\psi}\}\)</span> which, due to the linearity of the constraint, can be thought of as an affine hyperplane embedded in <span class="math inline">\(\Theta \subseteq \mathbb{R}^G_{&gt;0}\)</span>. Recall from Section 2 of Chapter 5 that elements of <span class="math inline">\(\Omega_{\hat{\psi}}\)</span> play the role of the ZSE parameter in models for which the nuisance parameter is implicit. Let <span class="math inline">\(Q(\theta; \omega)\)</span> represent the expected value of <span class="math inline">\(\ell(\theta; Y)\)</span> under the probability distribution indexed by an element <span class="math inline">\(\omega \in \Omega_{\hat{\psi}}\)</span>. That is, <span class="math display">\[
\begin{aligned}
Q(\theta; \omega) &amp;:= \text{E}_{\omega}[\ell(\theta; Y)] \\
                  &amp;= \text{E}_{\omega}\Bigg[\sum_{g=1}^G \big(Y_g \log \theta_g - t_g \theta_g\big)\Bigg] \\
                  &amp;= \sum_{g=1}^G \big(\text{E}_{\omega_g}[Y_g] \log \theta_g - t_g \theta_g\big) \\
                  &amp;= \sum_{g=1}^G \big(t_g\omega_g \log \theta_g - t_g \theta_g\big).
\end{aligned}
\]</span></p>
<p>For a given value of <span class="math inline">\(\psi\)</span>, the ZSE-constrained optimizer is <span class="math display">\[
\tilde{\theta}(\psi; \omega) := \arg \max_{\substack{\theta}} Q(\theta; \omega) \&gt; \text{ s.t. } \&gt; \alpha^{\top} \theta = \psi.
\]</span> Evaluating <span class="math inline">\(L(\theta; Y) := \exp(\ell(\theta; Y))\)</span> at <span class="math inline">\(\theta = \tilde{\theta}(\psi; \omega)\)</span> gives us a mapping from <span class="math inline">\(\psi\)</span> to its associated likelihood value under the distribution indexed by <span class="math inline">\(\omega\)</span>. If we integrate this mapping over <span class="math inline">\(\Omega_{\hat{\psi}}\)</span> with respect to some weight function <span class="math inline">\(\pi(\omega)\)</span> that doesn’t depend on <span class="math inline">\(\psi\)</span>, we can obtain the integrated likelihood function for <span class="math inline">\(\psi\)</span> based on the ZSE parameterization, i.e.</p>
<p><span class="math display">\[\bar{L}(\psi) = \int_{\Omega_{\hat{\psi}}} L(\tilde{\theta}(\psi; \omega)) \pi(\omega) d\omega.\]</span></p>
<p>Unsurprisingly, no closed-form solution exists for this integral. Instead, we can use Monte Carlo integration to approximate it with the following estimator:</p>
<p><span class="math display">\[\hat{\bar{L}}(\psi) = \frac{1}{R} \sum_{j=1}^R L(\tilde{\theta}(\omega^{(j)}; \psi); Y),\]</span> where the choice of <span class="math inline">\(\pi(\omega)\)</span> is now understood to be defined implicitly as the density function admitted by the probability measure <span class="math inline">\(d\Pi(\omega)\)</span> that governs how each <span class="math inline">\(\omega^{(j)}\)</span> is drawn from <span class="math inline">\(\Omega_{\hat{\psi}}\)</span>. As long as the selection does not depend on the value of <span class="math inline">\(\psi\)</span>, we are essentially free to choose any (non-degenerate) probability distribution we wish, and the form of <span class="math inline">\(\pi(\omega)\)</span> will be adjusted accordingly.</p>
<p>We can think of the functions <span class="math inline">\(L(\tilde{\theta}(\omega^{(j)}; \psi); Y)\)</span> for <span class="math inline">\(j = 1, ..., R\)</span> as being individual “branches” of the integrated likelihood that we average to obtain an estimate of its true underlying value at a particular value of <span class="math inline">\(\psi\)</span>. If we define the branch curve <span class="math display">\[b_{\omega}(\psi) := \log L(\tilde{\theta}(\psi; \omega^{(j)}); Y),\]</span> its corresponding mode is given by <span class="math display">\[\psi^*_{\omega} := \arg \max_{\substack{\psi}} b_{\omega}(\psi).\]</span> In general, for an arbitrary model and parameter of interest, there is no reason to expect that for two distinct values <span class="math inline">\(\omega^{(1)}, \omega^{(2)} \in \Omega_{\hat{\psi}}\)</span>, their corresponding branch curve modes <span class="math inline">\(\psi^*_{\omega^{(1)}}\)</span> and <span class="math inline">\(\psi^*_{\omega^{(2)}}\)</span> will be equal. For this specific case of estimating the weighted sum of a group of Poisson rates, however, we will prove that every branch will have the same mode regardless of the value of <span class="math inline">\(\omega\)</span> from which it came, and furthermore that mode will simply be the unconstrained MLE for <span class="math inline">\(\psi\)</span>, given by <span class="math inline">\(\hat{\psi} = \alpha^{\top} \hat{\theta}\)</span>.</p>
<p><strong>Proposition</strong>: <span class="math inline">\(\psi^*_{\omega} = \hat{\psi}\)</span> for all <span class="math inline">\(\omega \in \Omega_{\hat{\psi}}\)</span>.</p>
<p><strong>Proof</strong>: It suffices to show that an arbitrary branch curve <span class="math inline">\(b_{\omega}(\psi)\)</span> has a stationary point at <span class="math inline">\(\psi = \hat{\psi}\)</span>, i.e.&nbsp;<span class="math inline">\(b'_{\omega}(\hat{\psi}) = 0\)</span>. Since <span class="math inline">\(\ell(\theta; Y)\)</span> is concave in <span class="math inline">\(\theta\)</span> and the mapping <span class="math inline">\(\psi \mapsto \tilde{\theta}(\psi; \omega)\)</span> is smooth, such a point will be the unique maximizer of <span class="math inline">\(b_{\omega}(\psi)\)</span>. Differentiating the branch yields <span id="eq-7.0"><span class="math display">\[b'_{\omega}({\psi}) = \nabla_{\theta} \ell(\tilde{\theta}(\psi; \omega); Y)^\top\frac{\partial\tilde{\theta}(\psi; \omega)}{\partial \psi}. \tag{1}\]</span></span></p>
<p>Thus, we need to be able to evaluate both the ZSE optimizer <span class="math inline">\(\tilde{\theta}(\psi; \omega)\)</span> and its partial derivative with respect to <span class="math inline">\(\psi\)</span> at <span class="math inline">\(\psi = \hat{\psi}\)</span>. Recall that to evaluate <span class="math inline">\(\tilde{\theta}(\psi; \omega)\)</span> at a point <span class="math inline">\(\psi\)</span> for a given <span class="math inline">\(\omega\)</span> is to solve the constrained maximization problem <span class="math display">\[\arg \max_{\substack{\theta}} \sum_{g=1}^G \big(t_g\omega_g \log \theta_g - t_g \theta_g\big) \&gt; \text{ s.t. } \&gt; \alpha^{\top} \theta = \psi.\]</span> We proceed by the method of Lagrange multipliers. For some multiplier <span class="math inline">\(\lambda\)</span> (which may depend on <span class="math inline">\(\psi\)</span> and <span class="math inline">\(\omega\)</span>), define the Lagrangian function <span class="math display">\[\mathcal{L}(\theta, \lambda) = \sum_{g=1}^G \big(t_g\omega_g \log \theta_g - t_g \theta_g\big) + \lambda\Bigg[\psi - \sum_{g=1}^G \alpha_g \theta_g\Bigg].\]</span> Per the Lagrange multiplier theorem, the solution to the maximization problem will satisfy <span id="eq-7.1"><span class="math display">\[\frac{\partial \mathcal{L}(\theta, \lambda)}{\theta_g}\Bigg|_{\theta_g = \tilde{\theta}_g} = 0, \&gt; \&gt; \text{for } g = 1, ..., G \tag{2}\]</span></span> and <span id="eq-7.2"><span class="math display">\[\frac{\partial \mathcal{L}(\theta, \lambda)}{\lambda} = 0. \tag{3}\]</span></span> From <a href="#eq-7.1" class="quarto-xref">Equation&nbsp;2</a>, we have <span class="math display">\[\frac{t_g\omega_g}{\tilde{\theta_g}} - t_g - \lambda\alpha_g = 0.\]</span> This implies that the optimal solution <span class="math inline">\(\tilde{\theta}\)</span>, viewed here as a function of <span class="math inline">\(\lambda\)</span>, satisfies <span id="eq-7.3"><span class="math display">\[\tilde{\theta}_g(\lambda) = \frac{t_g \omega_g}{t_g + \lambda\alpha_g}. \tag{4}\]</span></span> Paired with the constraint condition enforced by <a href="#eq-7.2" class="quarto-xref">Equation&nbsp;3</a>, this in turn implies that the optimal value of <span class="math inline">\(\lambda\)</span> will satisfy <span id="eq-7.4"><span class="math display">\[\sum_{g=1}^G \alpha_g \tilde{\theta}_g(\lambda) = \psi. \tag{5}\]</span></span> Note that <span class="math inline">\(\lambda = 0 \iff \tilde{\theta} = \omega \iff \psi = \hat{\psi}\)</span>. It follows that <span class="math inline">\(\tilde{\theta}(\hat{\psi}; \omega) = \omega.\)</span></p>
<p>Turning our attention now to the derivative of the ZSE optimizer with respect to <span class="math inline">\(\psi\)</span>, we have that <span class="math display">\[\frac{\partial\tilde{\theta}_g}{\partial \psi} = \frac{\partial\tilde{\theta}_g}{\partial \lambda} \frac{d\lambda}{d \psi}.\]</span> From <a href="#eq-7.3" class="quarto-xref">Equation&nbsp;4</a>, we can compute <span class="math display">\[\frac{\partial\tilde{\theta}_g}{\partial \lambda} = -\frac{t_g\omega_g\alpha_g}{(t_g + \lambda\alpha_g)^2}.\]</span> At <span class="math inline">\(\lambda = 0\)</span>, this evaluates to <span class="math display">\[\frac{\partial\tilde{\theta}_g}{\partial \lambda}\Bigg|_{\lambda = 0} = -\frac{\omega_g\alpha_g}{t_g}.\]</span> Similarly, differentiating both sides of <a href="#eq-7.4" class="quarto-xref">Equation&nbsp;5</a> with respect to <span class="math inline">\(\psi\)</span> gives <span class="math display">\[\sum_{g=1}^G \alpha_g \frac{\partial\tilde{\theta}_g}{\partial \lambda} \frac{d \lambda}{d \psi} = 1 \implies \frac{d \lambda}{d \psi} = \frac{1}{\sum_{g=1}^G \alpha_g \frac{\partial\tilde{\theta}_g}{\partial \lambda}}.\]</span> At <span class="math inline">\(\psi = \hat{\psi}\)</span>, this evaluates to <span class="math display">\[\frac{d \lambda}{d \psi}\Bigg|_{\psi = \hat{\psi}} = \frac{1}{\sum_{g=1}^G \alpha_g \frac{\partial\tilde{\theta}_g}{\partial \lambda}\Big|_{\lambda = 0}} = -\frac{1}{\sum_{g=1}^G \alpha_g^2 \omega_g / t_g}.\]</span> Thus <span class="math display">\[
\begin{aligned}
\frac{\partial\tilde{\theta}_g}{\partial \psi}\Bigg|_{\psi = \hat{\psi}} &amp;= \frac{\partial\tilde{\theta}_g}{\partial \lambda}\Bigg|_{\lambda = 0} \cdot \frac{d\lambda}{d \psi}\Bigg|_{\psi = \hat{\psi}} \\
                                                                         &amp;= \bigg(-\frac{\omega_g\alpha_g}{t_g}\bigg) \Bigg(-\frac{1}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h}\Bigg) \\
                                                                         &amp;= \frac{\alpha_g\omega_g/t_g}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h},
\end{aligned}
\]</span> where we have changed the index of summation from <span class="math inline">\(g\)</span> to <span class="math inline">\(h\)</span> in the denominator of the final two lines to avoid confusion with the particular index <span class="math inline">\(g\)</span> being considered in the numerator.</p>
<p>Returning to <a href="#eq-7.0" class="quarto-xref">Equation&nbsp;1</a>, we can now compute <span class="math display">\[
\begin{aligned}
b'_{\omega}({\hat{\psi}}) &amp;= \Bigg[\nabla_{\theta} \ell(\tilde{\theta}(\psi; \omega); Y)\Bigg|_{\psi = \hat{\psi}}\Bigg]^\top\Bigg[\frac{\partial\tilde{\theta}(\psi; \omega)}{\partial \psi} \Bigg|_{\psi = \hat{\psi}}\Bigg] \\
                          &amp;= \sum_{g=1}^G \Bigg(\frac{\partial \ell}{\partial \theta_g}\Bigg|_{\theta_g = \tilde{\theta}_g(\hat{\psi}; \omega)}\Bigg)\Bigg(\frac{\partial\tilde{\theta}_g}{\partial \psi}\Bigg|_{\psi = \hat{\psi}}\Bigg) \\
                          &amp;= \sum_{g=1}^G \Bigg(\frac{Y_g}{\tilde{\theta}_g(\hat{\psi}; \omega)} - t_g\Bigg)\Bigg(\frac{\alpha_g\omega_g/t_g}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h}\Bigg) \\
                          &amp;= \sum_{g=1}^G \Bigg(\frac{Y_g}{\omega_g} - t_g\Bigg)\Bigg(\frac{\alpha_g\omega_g/t_g}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h}\Bigg) \\
                          &amp;= \frac{1}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h}\sum_{g=1}^G \alpha_g\Bigg(\frac{Y_g}{t_g} - \omega_g\Bigg) \\
                          &amp;= \frac{1}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h}\Bigg(\sum_{g=1}^G \alpha_g\hat{\theta}_g - \sum_{g=1}^G\alpha_g\omega_g\Bigg) \\
                          &amp;= \frac{1}{\sum_{h=1}^H \alpha_h^2 \omega_h / t_h}(\hat{\psi} - \hat{\psi}) \\
                          &amp;= 0.
\end{aligned}
\]</span></p>
<p><span class="math inline">\(\therefore \&gt; \&gt; b'_{\omega}({\hat{\psi}}) = 0\)</span>.</p>
<p>Since the choice of branch was arbitrary, this holds true for all <span class="math inline">\(\omega \in \Omega_{\hat{\psi}}\)</span>.</p>
<p><span class="math inline">\(\therefore \&gt; \psi^*_{\omega} = \hat{\psi}\)</span> for all <span class="math inline">\(\omega \in \Omega_{\hat{\psi}}. \hfill \blacksquare\)</span></p>
<p>The behavior of the integrated likelihood for <span class="math inline">\(\psi\)</span> under the ZSE parameterization is near-identical to that of the profile likelihood.</p>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>